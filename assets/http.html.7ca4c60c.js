import{r as e,o as a,c as n,a as l,w as r,F as s,b as t,d as i}from"./app.26466922.js";const o={},c=l("h1",{id:"http",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#http","aria-hidden":"true"},"#"),t(" HTTP")],-1),p={class:"table-of-contents"},d=t("浏览器缓存"),h=t("缓存最佳策略"),u=t("缓存有效期计算"),g=t("HTTPS"),b=t("CORS"),m=t("返回状态码"),f=t("GET 与 POST 区别"),x=t("请描述 cookies、sessionStorage 和 localStorage 的区别?"),w=t("http 与 tcp 区别"),S=t("DNS"),T=t("TCP"),k=t("Etag 和 Last-Modified 区别，使用场景"),C=t("Expires和Cache-Control"),E=t("幂等性"),_=i('<p>名词： ETag 文件指纹，如 content hash</p><h2 id="浏览器缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a> 浏览器缓存</h2><p>http cache 设计原则</p><p>默认隐式，显式用 cache-control</p><p>请求和响应，都能带指令，有冲突时，以更严格为准</p><p>两种模型：</p><ol><li><p>过期模型，减少频繁请求网络往返 Expires Cache-Control max-age 优先级高于上者</p></li><li><p>验证模型，减少带宽开销 条件请求 Last-Modified 默认弱验证 Etag 默认强验证</p><p>建议同时提供 Etag 和 LM 前者文件一变就变，后者在发生有意义变化时变</p></li></ol><p>启发式过期，慎用，建议明确指定</p><p>如何比对 ETag 和 LM，请求时带上之前的，即 If-xxx</p><p>流程：是否命中强缓存 -&gt; 是否命中协商缓存</p>',10),v={href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.1.5",target:"_blank",rel:"noopener noreferrer"},L=t("HTTP/1.1: Caching in HTTP"),P=i("<li><p>强缓存<code>header -&gt; max, cache</code>命中时不发网络请求</p></li><li><p>协商缓存<code>header -&gt; modifier</code>先发请求，命中 返回 304</p><p><code>no-cache</code> = store + if change 如果存在合适的验证令牌(ETag)，发起请求，如果资源无变化，304，不下载</p><p><code>no-store</code> 完全不存储，如私密文件</p></li><li><p>刷新(F5)，跳过强缓存，但是会检查协商缓存（协商缓存本身已经是一种避免内容不更新的策略，没必要跳过强刷）</p></li>",3),M=l("p",null,"强制刷新(Ctrl + F5)，跳过强缓存和协商缓存",-1),O={href:"https://www.cnblogs.com/lyzg/p/5125934.html",target:"_blank",rel:"noopener noreferrer"},N=t("浏览器缓存知识小结及应用 - 流云诸葛 - 博客园"),H={href:"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},D=t("HTTP 缓存  |  Web  |  Google Developers"),q={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching",target:"_blank",rel:"noopener noreferrer"},y=t("HTTP caching - HTTP | MDN"),R=l("li",null,[l("p",null,"不设置"),l("ul",null,[l("li",null,"跳转访问 size 列 显示 disk cache 或请求详情 General 显示 Status Code: 200 OK (from disk cache)"),l("li",null,[t("直接打开资源链接，chrome 会在请求头加上"),l("code",null,"max-age=0"),t("，走协商缓存 显示 304，不需要再接收响应体，节省一些带宽")]),l("li",null,"浏览器缓存策略有差异，所以不需要缓存时，最好显式指定")])],-1),I=l("li",null,[l("p",null,"共享代理缓存 VS 私人浏览器缓存"),l("p",null,"共享缓存可以存在中间服务器上（只是个概念，如 cdn）")],-1),A=i('<h3 id="缓存最佳策略" tabindex="-1"><a class="header-anchor" href="#缓存最佳策略" aria-hidden="true">#</a> 缓存最佳策略</h3><ul><li>For html files, use Cache-Control: no-cache, and Etag. 协商缓存</li><li>For js,css, and image files, set Cache-Control: public, max-age=31536000, no Etag, no Last-Modified settings. 强缓存，因为新资源 URL 一般有版本</li></ul><h3 id="缓存有效期计算" tabindex="-1"><a class="header-anchor" href="#缓存有效期计算" aria-hidden="true">#</a> 缓存有效期计算</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// freshnessLifetime\nif `Cache-control: max-age=N` exist\n  = N\nelse if `Expires` exist\n  = Expires - Date\nelse if `Last-Modified` exist\n  = (Date - Last-Modified) / 10\n\nexpirationTime = responseTime + freshnessLifetime - currentAge\n\nresponseTime 浏览器接收响应时间\ncurrentAge = currentTime - storeTime\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>meta cache-control 不建议用，html4 标准，5 没有</p>',5),F={href:"https://stackoverflow.com/questions/49547/how-do-we-control-web-page-caching-across-all-browsers",target:"_blank",rel:"noopener noreferrer"},z=t("http - How do we control web page caching, across all browsers? - Stack Overflow"),G=l("h2",{id:"https",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#https","aria-hidden":"true"},"#"),t(" HTTPS")],-1),K=l("p",null,"建立在 SSL/TLS 协议上，采用了公钥加密法，基本过程是：",-1),j=l("ol",null,[l("li",null,"客户端向服务器端索要并验证公钥。"),l("li",null,"双方协商生成”会话密钥”。"),l("li",null,"双方采用”会话密钥”进行加密通信")],-1),U=l("p",null,"数据通信 对称加密 签名 非对称加密",-1),W=l("p",null,"SSL 握手 s => send pubkey => c c => 生成对称加密 session key ，并用 pubkey 加密 => s 用私钥解密 之后使用对称加密 key 数据传输",-1),Y={href:"https://www.quora.com/Does-SSL-and-TLS-use-asymmetric-encryption",target:"_blank",rel:"noopener noreferrer"},V=t("Does SSL and TLS use asymmetric encryption? - Quora"),Q=l("h2",{id:"cors",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#cors","aria-hidden":"true"},"#"),t(" CORS")],-1),B=l("p",null,"CORS 处理非简单请求（如 POST）会触发 options",-1),X=t("Access-Control-Max-Age 指定 prelight 请求缓存多长时间，这个时间内不再需要发 "),J={href:"https://blog.csdn.net/wanwan5856/article/details/79592681",target:"_blank",rel:"noopener noreferrer"},Z=t("减少 options 请求次数 和 数据量大时前端渲染的处理 - wanwan5856 的博客 - CSDN 博客"),$=i('<p>简单请求的定义，来自 MDN，不是标准。简单请求要满足一系列条件，如仅使用 CORS 安全 请求头。而需要 prelight 的请求，意味着涉及用户数据</p><h2 id="返回状态码" tabindex="-1"><a class="header-anchor" href="#返回状态码" aria-hidden="true">#</a> 返回状态码</h2><p>助记：1-5 / I OR CS</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1xx 信息 Information(I)\n2xx 成功 OK(O)\n3xx 重定向 Redirect(R)\n4xx 客户端错误 Client Error(C)\n5xx 服务端错误 Server Error(S)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>pragma 〔计〕杂注,编译指示</p><p>交换完连接即关闭，而长连接(HTTP1.1)只有在服务端收到<code>Connection: close</code>才会关闭</p><ul><li>206 - 大文件分块下载时使用 <code>curl --header &quot;Range: bytes=500-1000&quot; https://raw.githubusercontent.com/Germey/LaravelGeetest/master/README.md</code></li></ul><h2 id="get-与-post-区别" tabindex="-1"><a class="header-anchor" href="#get-与-post-区别" aria-hidden="true">#</a> GET 与 POST 区别</h2><ul><li>用途</li><li>参数形式</li><li>编码</li><li>安全性</li></ul><p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）； 而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p><p>get 只读，cdn 缓存</p><p>post 副作用，需要 web 服务器操作</p><p>100 continue 并非 post 必然使用，使用场景是 post/put，发送大量数据场景的请求优化</p>',13),ee={href:"https://gms.tf/when-curl-sends-100-continue.html",target:"_blank",rel:"noopener noreferrer"},ae=t("When curl sends 100-continue | Georg's Log"),ne={href:"https://www.zhihu.com/question/31640769",target:"_blank",rel:"noopener noreferrer"},le=t("post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？ - 知乎"),re=i('<h2 id="请描述-cookies、sessionstorage-和-localstorage-的区别" tabindex="-1"><a class="header-anchor" href="#请描述-cookies、sessionstorage-和-localstorage-的区别" aria-hidden="true">#</a> 请描述 cookies、sessionStorage 和 localStorage 的区别?</h2><ol><li>存储方式：cookies 存储在 http 信息的实体中，http 每次请求都会携带 cookie, cookie 在浏览器和服务器间来回传递， 后两者仅在本地保存</li><li>存储大小：cookie 数据不能超过 4k; 后两者要大很多，可以达到 5M</li><li>有效期：cookie 在设置的 cookie 有效期之前有效，即使浏览器或窗口关闭；sessionStorage 仅在当前浏览器窗口关闭前有效，不可持久保存；localSorage 始终有效，窗口或浏览器关闭也一直保存，可做持久数据</li><li>作用域：cookie、localStorage 在所有的同源窗口中都是共享的；sessionStorage 只能在当前页面使用</li></ol><p>sessionStorage</p><ul><li>刷新或恢复页面（重新打开关闭的标签页）时，session 存在</li><li>创建一个新的相同 URL 页面，会创建新的 session</li><li>试验 https://codesandbox.io/s/992th?file=/src/index.js</li></ul>',4),se=t("sessionStorage, localStorage 存储 size 限制 5MB，各浏览器一致，同步执行，可阻塞主线程 "),te={href:"https://web.dev/storage-for-the-web/#check",target:"_blank",rel:"noopener noreferrer"},ie=t("Storage for the web"),oe=l("h2",{id:"http-与-tcp-区别",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#http-与-tcp-区别","aria-hidden":"true"},"#"),t(" http 与 tcp 区别")],-1),ce=l("ul",null,[l("li",null,"tcp 是传输层，http 是跑在 tcp 上的应用层协议")],-1),pe={href:"https://www.infoq.cn/article/x80uOvcRyxVYw3KVusUm",target:"_blank",rel:"noopener noreferrer"},de=t("HTTP/3 的过去、现在和未来-InfoQ"),he=i('<h2 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h2><ol><li>浏览器 cache</li><li>操作系统 cache</li><li>路由器 cache</li><li>ISP 网络运营商 cache (以上递归查询 - dns 服务器)</li><li>root (以下 迭代查询)</li><li>域</li><li>权威解析服务器 - 返回 IP</li></ol><p>流程：解析-请求-渲染</p>',3),ue=t("递归查询-客户端查一次，迭代查询-客户端反复查 "),ge={href:"https://www.cnblogs.com/xiangsikai/p/8438601.html",target:"_blank",rel:"noopener noreferrer"},be=t("DNS 递归/迭代 原理 - kevin.Xiang - 博客园"),me={href:"https://github.com/lgwebdream/FE-Interview/issues/14#issuecomment-647606369",target:"_blank",rel:"noopener noreferrer"},fe=t("第 8 题：说一下 Http 缓存策略，有什么区别，分别解决了什么问题 · Issue #14 · lgwebdream/FE-Interview"),xe={href:"https://www.jianshu.com/p/54cc04190252",target:"_blank",rel:"noopener noreferrer"},we=t("深入理解浏览器的缓存机制 - 简书"),Se=i('<h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><p>TCP 三次握手，建立可靠连接，双边要同步(SYN)和确认(ACK)</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>C -&gt; SYN -&gt; S\nC &lt;- SYN-ACK &lt;- S\nC -&gt; ACK -&gt; S\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>序列号和确认号的使用允许双方检测丢失或乱序的数据片段</p><p>https://www.google.com/search?q=tcp+handshake&amp;oq=tcp+handshake&amp;aqs=chrome..69i57.6609j0j7&amp;sourceid=chrome&amp;ie=UTF-8</p><p>四次挥手 Finish</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>C -&gt; FIN -&gt; S\nC &lt;- ACK &lt;- S\nC &lt;- keep send and FIN &lt;- S\nC -&gt; ACK -&gt; S\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>',7),Te={href:"https://wiki.wireshark.org/TCP%25204-times%2520close",target:"_blank",rel:"noopener noreferrer"},ke=t("TCP 4-times close - The Wireshark Wiki"),Ce=i('<h2 id="etag-和-last-modified-区别-使用场景" tabindex="-1"><a class="header-anchor" href="#etag-和-last-modified-区别-使用场景" aria-hidden="true">#</a> Etag 和 Last-Modified 区别，使用场景</h2><ul><li>优先级</li><li>准确性、及时性</li><li>场景</li></ul><blockquote><p>Etag nginx 是基于 Last-Modified 和 Content-Length 计算，更新更及时？</p></blockquote><h2 id="expires和cache-control" tabindex="-1"><a class="header-anchor" href="#expires和cache-control" aria-hidden="true">#</a> Expires和Cache-Control</h2><p>Expires 要求客户端和服务端的时钟严格同步。 HTTP1.1 引入 Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则 max-age 有更高的优先级。</p>',5),Ee=t("Last-Modified 与 Etag 对比，精确度、分布式部署一致性、性能消耗、优先级 "),_e={href:"https://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&mid=2451060772&idx=3&sn=3ee0c658dd84a6e481bb3cc14e502a04&chksm=87c42134b0b3a822122a78b3bb676d122c0fbcd280dc9facd0c19e7cbe4b638ab09b283c590d#rd",target:"_blank",rel:"noopener noreferrer"},ve=t("通过 Node.js 小示例学习浏览器缓存策略"),Le=l("h2",{id:"幂等性",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#幂等性","aria-hidden":"true"},"#"),t(" 幂等性")],-1),Pe=l("p",null,"什么是幂等？一个操作如果具有任意多次执行所产生的影响均与一次执行的影响相同，我们就称之为幂等。",-1),Me=l("p",null,"POST 不满足，多次调用创建多个",-1),Oe=l("p",null,"GET/PUT/DELETE 满足",-1),Ne=l("p",null,"幂等设计的作用是，允许客户端多次重试，而不产生意外副作用",-1);o.render=function(t,i){const o=e("RouterLink"),He=e("OutboundLink");return a(),n(s,null,[c,l("nav",p,[l("ul",null,[l("li",null,[l(o,{to:"#浏览器缓存"},{default:r((()=>[d])),_:1}),l("ul",null,[l("li",null,[l(o,{to:"#缓存最佳策略"},{default:r((()=>[h])),_:1})]),l("li",null,[l(o,{to:"#缓存有效期计算"},{default:r((()=>[u])),_:1})])])]),l("li",null,[l(o,{to:"#https"},{default:r((()=>[g])),_:1})]),l("li",null,[l(o,{to:"#cors"},{default:r((()=>[b])),_:1})]),l("li",null,[l(o,{to:"#返回状态码"},{default:r((()=>[m])),_:1})]),l("li",null,[l(o,{to:"#get-与-post-区别"},{default:r((()=>[f])),_:1})]),l("li",null,[l(o,{to:"#请描述-cookies、sessionstorage-和-localstorage-的区别"},{default:r((()=>[x])),_:1})]),l("li",null,[l(o,{to:"#http-与-tcp-区别"},{default:r((()=>[w])),_:1})]),l("li",null,[l(o,{to:"#dns"},{default:r((()=>[S])),_:1})]),l("li",null,[l(o,{to:"#tcp"},{default:r((()=>[T])),_:1})]),l("li",null,[l(o,{to:"#etag-和-last-modified-区别-使用场景"},{default:r((()=>[k])),_:1})]),l("li",null,[l(o,{to:"#expires和cache-control"},{default:r((()=>[C])),_:1})]),l("li",null,[l(o,{to:"#幂等性"},{default:r((()=>[E])),_:1})])])]),_,l("p",null,[l("a",v,[L,l(He)])]),l("ul",null,[P,l("li",null,[M,l("p",null,[l("a",O,[N,l(He)])]),l("p",null,[l("a",H,[D,l(He)])]),l("p",null,[l("a",q,[y,l(He)])])]),R,I]),A,l("p",null,[l("a",F,[z,l(He)])]),G,K,j,U,W,l("p",null,[l("a",Y,[V,l(He)])]),Q,B,l("p",null,[X,l("a",J,[Z,l(He)])]),$,l("p",null,[l("a",ee,[ae,l(He)]),l("a",ne,[le,l(He)])]),re,l("p",null,[se,l("a",te,[ie,l(He)])]),oe,ce,l("p",null,[l("a",pe,[de,l(He)])]),he,l("p",null,[ue,l("a",ge,[be,l(He)])]),l("p",null,[l("a",me,[fe,l(He)])]),l("p",null,[l("a",xe,[we,l(He)])]),Se,l("p",null,[l("a",Te,[ke,l(He)])]),Ce,l("p",null,[Ee,l("a",_e,[ve,l(He)])]),Le,Pe,Me,Oe,Ne],64)};export default o;
