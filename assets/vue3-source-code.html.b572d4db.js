import{r as e,o as n,c as a,a as s,w as r,F as p,b as l,d as t}from"./app.26466922.js";const c={},i=s("h1",{id:"vue-3-源码学习",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#vue-3-源码学习","aria-hidden":"true"},"#"),l(" Vue 3 源码学习")],-1),u={class:"table-of-contents"},b=l("调试"),o=l("目录结构"),d=l("模块关系"),m=l("createApp"),v=l("core api - runtime"),f=l("reactive"),h=l("讨论点"),g=l("参考"),x=t('<h2 id="调试" tabindex="-1"><a class="header-anchor" href="#调试" aria-hidden="true">#</a> 调试</h2><p>git clone git@github.com:vuejs/core.git vue3-core</p><h2 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h2><p>packages</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>.\n├── compiler-core // 编译核心，抽象语法树和渲染桥接实现\n├── compiler-dom // Dom 实现\n├── compiler-sfc // SFC 单文件组件(.vue)的实现\n├── compiler-ssr\n├── global.d.ts\n├── reactivity // 响应式\n├── runtime-core\n├── runtime-dom\n├── runtime-test\n├── server-renderer // 服务端渲染实现\n├── shared  // package 之间共享的工具库\n├── size-check\n├── template-explorer\n└── vue // 入口？\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>compiler、runtime 概念区别 compiler 源码到可执行代码，runtime 程序运行时</p><h2 id="模块关系" tabindex="-1"><a class="header-anchor" href="#模块关系" aria-hidden="true">#</a> 模块关系</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>vue - packages/vue/src/index.ts\n    @vue/compiler-dom\n        @vue/compiler-core\n    @vue/runtime-dom\n        @vue/runtime-core\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="createapp" tabindex="-1"><a class="header-anchor" href="#createapp" aria-hidden="true">#</a> createApp</h2><p>方法关系：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>createRenderer\n baseCreateRenderer\n   createAppAPI\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// packages/runtime-core/src/renderer.ts\nfunction baseCreateRenderer\n  ...\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>createAppAPI</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>app\n  use(plugin: Plugin, ...options: any[]) {\n  mixin(mixin: ComponentOptions) {\n  component(name: string, component?: Component): any {\n  directive(name: string, directive?: Directive) {\n\n  mount(\n  unmount() {\n  provide(key, value) {\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><pre><code>propsCache: new WeakMap(),\n</code></pre><h2 id="core-api-runtime" tabindex="-1"><a class="header-anchor" href="#core-api-runtime" aria-hidden="true">#</a> core api - runtime</h2><p><code>packages/runtime-core/src/index.ts</code>负责将最常用方法、API 导出</p><p>defineComponent 类型 util</p><p>h - Hyperscript 参数判断，实际调用 createVNode</p><p>v-if/v-for 视为 block，可能动态变更</p><h2 id="reactive" tabindex="-1"><a class="header-anchor" href="#reactive" aria-hidden="true">#</a> reactive</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c884b48e88a643e2b695b3587224b51d~tplv-k3u1fbpfcp-watermark.awebp" alt="reactive 工作流程"></p><p>文件结构</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>└── src\n    ├── baseHandlers.ts // 基本类型的处理器\n    ├── collectionHandlers.ts  // Set Map WeakSet WeckMap的处理器\n    ├── computed.ts // 计算属性，同Vue2\n    ├── deferredComputed.ts // 计算属性\n    ├── dep.ts // \n    ├── effect.ts // reactive 核心，处理依赖收集，依赖更新\n    ├── effectScope.ts // \n    ├── index.ts\n    ├── operations.ts // 定义依赖收集，依赖更新的类型\n    ├── reactive.ts // reactive 入口，内部主要以 Proxy 实现\n    └── ref.ts // Proxy 处理不了值类型的响应，Ref 来处理\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>ref 实现</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ref( 默认深拷贝\n  createRef(\n    RefImpl(\n      toReactive 对象调用 reactive，非对象直接返回\n         sObject(value) ? reactive(value) : value\n            createReactiveObject(mutableHandlers\n                new Proxy\n      get 时，触发依赖收集、追踪\n        trackEffects\n      set 时，触发依赖更新\n        triggerEffects\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>官方文档：如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。</p></blockquote><p>effect 作为 reactive 的核心，主要负责监听响应式数据的变化，触发监听函数的执行逻辑</p><blockquote><p>Vue 最独特的特性之一，是其非侵入性的响应性系统。数据模型是被代理的 JavaScript 对象。</p></blockquote><p>原始类型响应式解决方案，转换成对象，增加<code>.value</code>，模板访问时自动解套</p><p>targetMap 记录 target object/property 和 effect 关系，二层数据结构：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>weakmap <span class="token operator">=</span> <span class="token punctuation">{</span>\n    targetObject<span class="token operator">:</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>\n        targetProperty<span class="token operator">:</span> dep<span class="token operator">&lt;</span>effect array<span class="token operator">&gt;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>effectStack <code>push -&gt; run -&gt; pop</code></p><p>activeEffect 当前运行的 effect</p><p>记录依赖关系时，查询 activeEffect</p><p>setupResult 是 setup return 的对象</p><h2 id="讨论点" tabindex="-1"><a class="header-anchor" href="#讨论点" aria-hidden="true">#</a> 讨论点</h2><p>数据和逻辑聚合</p><p>以功能或者职责来组织文件</p><p>新的 API 理论上会降低代码质量的最低门槛</p><p>setup 作用是为了合成生成物，供外部访问</p>',41),k={href:"https://stackoverflow.com/a/58500917",target:"_blank",rel:"noopener noreferrer"},y=l("vue.js - When to use setup() hook of Vue Composition API - Stack Overflow"),A=s("h2",{id:"参考",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),l(" 参考")],-1),j={href:"https://v3.cn.vuejs.org/guide/reactivity.html#%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E5%2593%258D%25E5%25BA%2594%25E6%2580%25A7",target:"_blank",rel:"noopener noreferrer"},P=l("深入响应性原理 | Vue.js"),_={href:"https://segmentfault.com/a/1190000039691166",target:"_blank",rel:"noopener noreferrer"},E=l("推荐 7 个 Vue2、Vue3 源码解密分析的重磅开源项目 👍 - SegmentFault 思否");c.render=function(l,t){const c=e("RouterLink"),R=e("OutboundLink");return n(),a(p,null,[i,s("nav",u,[s("ul",null,[s("li",null,[s(c,{to:"#调试"},{default:r((()=>[b])),_:1})]),s("li",null,[s(c,{to:"#目录结构"},{default:r((()=>[o])),_:1})]),s("li",null,[s(c,{to:"#模块关系"},{default:r((()=>[d])),_:1})]),s("li",null,[s(c,{to:"#createapp"},{default:r((()=>[m])),_:1})]),s("li",null,[s(c,{to:"#core-api-runtime"},{default:r((()=>[v])),_:1})]),s("li",null,[s(c,{to:"#reactive"},{default:r((()=>[f])),_:1})]),s("li",null,[s(c,{to:"#讨论点"},{default:r((()=>[h])),_:1})]),s("li",null,[s(c,{to:"#参考"},{default:r((()=>[g])),_:1})])])]),x,s("p",null,[s("a",k,[y,s(R)])]),A,s("p",null,[s("a",j,[P,s(R)]),s("a",_,[E,s(R)])])],64)};export default c;
