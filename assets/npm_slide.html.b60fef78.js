import{d as l}from"./app.31fc93bc.js";const i={},e=l('<h1 id="npm-可复现构建" tabindex="-1"><a class="header-anchor" href="#npm-可复现构建" aria-hidden="true">#</a> npm 可复现构建</h1><hr><p>package.json != 可复现构建</p><p>理想情况，输入<code>package.json</code>，输出确定<code>node_modules</code></p><hr><p>影响因素：</p><ul><li>使用不同版本 npm，安装算法略有差异</li><li>范围包，有更新，再安装时使用新版本</li><li>子依赖即使写死版本号，也会更新</li><li>安装包的远程库失效</li></ul><hr><p>npm install 策略</p><ol><li>存在有效 lockfile，根据 lockfile 还原安装</li><li>否则，根据 package.json 重新计算依赖生成 lockfile， 进行安装</li></ol><p>问题:部署用途时不能保证可靠还原</p><hr><p>5.7.1 -- <code>npm ci</code></p><p>只从 lockfile 进行复现安装 适用于纯净部署，比常规安装更快更严格，帮助捕获错误或增量安装引起的不一致</p><hr><ul><li>lockfile 与 <code>package.json</code> 依赖不匹配时，会报错，而不是更新 lockfile</li><li>如查<code>node_modules</code>存在，会先删掉</li><li>可以做为<code>npm i</code>失败的回退，大幅降低安装失败的情况</li></ul><hr><p>建议，构建严格按 lockfile，开发忽略</p><ul><li>保证构建稳定，不出现意料外依赖变化导致的问题</li><li>减少对开发者的工具要求，但要维护统一的 lockfile</li><li>开发和构建环境，npm 版本要限制最低 5.4.2</li><li>松散版本号的意义</li></ul><hr><p>缺点</p><ul><li>不易读，lockfile 被破坏不易察觉</li><li><code>package.json</code>无法反映真实使用依赖</li></ul><hr><p>完</p><hr>',25);i.render=function(l,i){return e};export default i;
