(window.webpackJsonp=window.webpackJsonp||[]).push([[381],{821:function(e,t,s){"use strict";s.r(t);var r=s(56),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"webassembly"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webassembly"}},[e._v("#")]),e._v(" WebAssembly")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://developer.ibm.com/technologies/web-development/articles/why-webassembly-and-rust-together-improve-nodejs-performance/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Why using WebAssembly and Rust improves Node.js performance – IBM Developer"),s("OutboundLink")],1)]),e._v(" "),s("blockquote",[s("p",[e._v("只从 chrome 来说，因为 wasm 和 js 的字节码最后公用的 是同一个 优化编译器(turbo fan) 如果你的应用不是非常计算密集，加上js和 wasm 之间通信的额外消耗， 最后的性能可能和 js 写的应用差不多， 甚至比 js 版本还差")])]),e._v(" "),s("blockquote",[s("p",[e._v("如果你只是写一个功能比较简单的应用练练手，直接用 rust-wasm 一整套工具链(wasm-pack, wasm-bindgen)应该可以比较快的完成目标，大概率你应该不会遇到 rust 语言的坑，所有权等。")])]),e._v(" "),s("p",[s("a",{attrs:{href:"https://ffmpegwasm.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("FFMPEG.WASM"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);