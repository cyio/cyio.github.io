import{r as e,o,c as d,a,F as r,b as c,d as l}from"./app.0e74f851.js";const t={},i=a("h1",{id:"mobx",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#mobx","aria-hidden":"true"},"#"),c(" Mobx")],-1),n=a("ul",null,[a("li",null,"autorun 立即执行一次"),a("li",null,"reaction(() => data, () => {}) 第一个参数返回观察数据"),a("li",null,"when(() => boolean, () => {}) 第一参数返回布尔值，为真时执行一次，然后销毁")],-1),p={href:"https://zhuanlan.zhihu.com/p/24613915",target:"_blank",rel:"noopener noreferrer"},h=c("[干货] 使用 Mobx 更好地处理 React 数据 - 知乎专栏"),s=l('<h2 id="子组件较多时-如何用-mobx-传递和共享数据" tabindex="-1"><a class="header-anchor" href="#子组件较多时-如何用-mobx-传递和共享数据" aria-hidden="true">#</a> 子组件较多时，如何用 mobx 传递和共享数据</h2><p>眼下的做法是父子共用一个 store，缺点是相互影响，很多数据需要手动重置</p><p>正确的做法是严格从上往下传数据，下级如果要改数据，使用回调</p><p>答案是 Provider 和 inject</p><h2 id="mobx-react" tabindex="-1"><a class="header-anchor" href="#mobx-react" aria-hidden="true">#</a> mobx-react</h2><ul><li><p><code>Observer</code>是一个组件，应用<code>observer</code>到你的组件的匿名区域，接受一个无参数函数，精确返回一个组件 使用装饰器，不用关注这一点</p></li><li><p><code>onError</code>全局错误处理，能避免导致应用崩溃，而是打印到日志</p></li><li><p>哪些组件应该标记为<code>observer</code>? 所有需要渲染可观察数据的组件</p></li><li><p><code>shouldComponentUpdate</code>应避免使用，由于 mobx 会默认提供一个高度优化的<code>shouldComponentUpdate</code>实现</p></li><li><p><code>componentWillReact</code> 是自动的，mobx 的数据变化，就会响应</p></li><li><p><code>Provider</code>是一个组件，通过 React 的上下文机制传递 stores 给子组件，而<code>inject</code>则是选取 stores 同时使用<code>@inject</code>和<code>@observer</code>时，<code>@inject</code>写在外面</p></li></ul><h2 id="学习-mobx-react-todomvc" tabindex="-1"><a class="header-anchor" href="#学习-mobx-react-todomvc" aria-hidden="true">#</a> 学习 mobx-react-todomvc</h2><ul><li>多了个 todoModal 类，传四个参数，store, id, title, completed 一些 todo 操作方法，加上与对象转换的方法</li><li>id 随机生成</li><li>子组件之所以能修改数据，就是从父级传下来不只是某个值，而是包括修改方法的类</li></ul>',8);t.render=function(c,l){const t=e("OutboundLink");return o(),d(r,null,[i,n,a("p",null,[a("a",p,[h,a(t)])]),s],64)};export default t;
