import{r as n,o as s,c as a,a as e,w as t,F as o,b as p,d as c}from"./app.31fc93bc.js";const l={},r=e("h1",{id:"对象",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#对象","aria-hidden":"true"},"#"),p(" 对象")],-1),i={class:"table-of-contents"},u=p("定义"),d=p("枚举"),b=p("深拷贝"),k=p("JSON.parse(JSON.stringify(obj))"),h=p("Object.assign"),m=p("场景应用"),g=p("字典"),j=c('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ul><li><p><code>{ key: value }</code> {任意字符串: 任意值}</p><p>对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的任意字符串，属性值可以是任意值</p></li><li><p>一个由空格或连字符，或者以数字开头,或者保留字的属性名，就只能通过方括号标记访问。这个标记法在属性名称是动态判定（属性名只有到运行时才能判定）时非常有用 <img src="http://wx4.sinaimg.cn/large/4e5d3ea7ly1fcj043tniuj206u06h3yj.jpg" alt=""></p><blockquote><p>从数据结构的角度来说，映射（Map）跟原本的 Object 非常相似，都是 Key/Value 的键值对结构。但是 Object 有一个让人非常不爽的限制：key 必须是字符串或数字。</p></blockquote></li></ul><h2 id="枚举" tabindex="-1"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h2><ul><li><code>Object.keys()</code>与<code>for-in</code>的输出顺序一致（会被重新排序），主要区别是后者还会返回原型链中属性（往往不是我们需要的）</li><li>遍历对象 1. for in 2. for of Object.keys(obj)</li><li>对象本身不是可迭代对象，原型上没有<code>Symbol(Symbol.iterator)</code></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>myvar <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 只能是对象成员，排除原型链</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>myvar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><code>Object.getOwnPropertyNames()</code>与<code>Object.keys()</code>的区别是，后者仅可以输出可枚举属性(哪些算不可枚举属性，继承的内置方法 fuction，注意前面方法中的 own) 简单说是 in 和 own 的区分，前者能取到继承属性</li></ul><h2 id="深拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a> 深拷贝</h2><p>数据层级：一层即为浅拷贝，针对引用类型这种深层次数据</p><p>ES5 用浅拷贝 + 递归解决</p><p>ES6 <code>Object.assign</code>和<code>...</code>扩展符不会做深拷贝，如果属性里有对象或数组，拷贝的是引用。注意，第一层拷贝并不是引用</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> one <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;jack&#39;</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>one <span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one <span class="token operator">===</span> two<span class="token punctuation">)</span>\n\none<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;jordan&#39;</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> three <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>one <span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>child <span class="token operator">===</span> three<span class="token punctuation">.</span>child<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>Object.assign</code>将多个对象复制到目标对象，与其说是复制，更像合并，如果有相同 key， 后边会覆盖前边</p><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>var obj1 = {a: 1}\nvar obj2 = {a: 3, b: 1}\nvar merge = Object.assign({}, obj1, obj2)\nconsole.log(merge)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>纯数据对象的话可以用 JSON 的接口，MDN 也是这个</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj_snapshot <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>可以用 lodash 的 cloneDeep 函数。 狠一点就上 immutable，facebook 官方出的，所有数据都是不可变，不需要深拷贝之类的操作</p><h3 id="json-parse-json-stringify-obj" tabindex="-1"><a class="header-anchor" href="#json-parse-json-stringify-obj" aria-hidden="true">#</a> JSON.parse(JSON.stringify(obj))</h3>',17),f=p("仅处理纯数据，函数不算 "),v={href:"https://stackoverflow.com/questions/18089033/json-stringify-does-not-process-object-methods",target:"_blank",rel:"noopener noreferrer"},y=p("javascript - json.stringify does not process object methods - Stack Overflow"),O=c('<h3 id="object-assign" tabindex="-1"><a class="header-anchor" href="#object-assign" aria-hidden="true">#</a> Object.assign</h3><p>参数：(target, source, ...)</p><p>注意会改变 target</p><p>如果只是想合并 <code>let merged = Object.assign({}, a, b)</code></p><h3 id="场景应用" tabindex="-1"><a class="header-anchor" href="#场景应用" aria-hidden="true">#</a> 场景应用</h3><ul><li>修改对象时，是否会影响原对象，对象只有一层值类型时、不影响</li><li>Echarts 需要复制 JSON 配置到在线 Playground 调试，如何复制</li></ul><p>检查数组的严格相等，意味着检查是否有相同内存地址或引用</p><p>浅比较，要求 key 相同，值严格相等。场景，如纯函数返回总是新值，React prop 数组传递</p><p>useMemo 依赖无变化时，返回旧引用</p><blockquote><p>“Memoization is an optimization technique used to primarily speed up programs by storing the results of expensive function calls and returning the cached results when the same inputs occur again.”</p></blockquote><p>手写题目：实现深拷贝 注意点：入参校验、对象判断、层级很深会栈溢出、循环引用、用 for in 遍历纯数据对象是合适的。拷贝时可以用三元表达式 第一次，isObject 判断后的赋值写错了</p>',11),x={href:"https://segmentfault.com/a/1190000016672263",target:"_blank",rel:"noopener noreferrer"},S=p("深拷贝的终极探索（99%的人都不知道） - 颜海镜 - SegmentFault 思否"),w=c('<h2 id="字典" tabindex="-1"><a class="header-anchor" href="#字典" aria-hidden="true">#</a> 字典</h2><p>尽量用 Map，其次用<code>Object.create</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const dict = Object.create(null)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',3),J={href:"https://exploringjs.com/impatient-js/ch_single-objects.html#the-pitfalls-of-using-an-object-as-a-dictionary",target:"_blank",rel:"noopener noreferrer"},_=p("Single objects • JavaScript for impatient programmers"),N={href:"https://everyday.codes/javascript/please-stop-using-classes-in-javascript/",target:"_blank",rel:"noopener noreferrer"},q=p("Please stop using classes in JavaScript | everyday.codes");l.render=function(p,c){const l=n("RouterLink"),M=n("OutboundLink");return s(),a(o,null,[r,e("nav",i,[e("ul",null,[e("li",null,[e(l,{to:"#定义"},{default:t((()=>[u])),_:1})]),e("li",null,[e(l,{to:"#枚举"},{default:t((()=>[d])),_:1})]),e("li",null,[e(l,{to:"#深拷贝"},{default:t((()=>[b])),_:1}),e("ul",null,[e("li",null,[e(l,{to:"#json-parse-json-stringify-obj"},{default:t((()=>[k])),_:1})]),e("li",null,[e(l,{to:"#object-assign"},{default:t((()=>[h])),_:1})]),e("li",null,[e(l,{to:"#场景应用"},{default:t((()=>[m])),_:1})])])]),e("li",null,[e(l,{to:"#字典"},{default:t((()=>[g])),_:1})])])]),j,e("p",null,[f,e("a",v,[y,e(M)])]),O,e("p",null,[e("a",x,[S,e(M)])]),w,e("p",null,[e("a",J,[_,e(M)]),e("a",N,[q,e(M)])])],64)};export default l;
