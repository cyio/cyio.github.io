import{r as e,o as a,c as n,a as i,F as r,d as s,b as t}from"./app.0e74f851.js";const d={},l=s('<h2 id="不兼容" tabindex="-1"><a class="header-anchor" href="#不兼容" aria-hidden="true">#</a> 不兼容</h2><ul><li>slot</li><li>filter</li><li>vue-router</li></ul><h2 id="目录结构特点" tabindex="-1"><a class="header-anchor" href="#目录结构特点" aria-hidden="true">#</a> 目录结构特点</h2><ul><li>pages 目录</li><li>每个页面由三部分组成</li><li>没有 app.vue</li><li>src/pages/live/index 会被编译为 dist/pages/live/live，全局 main.js 中的 export config 要按 dist 写</li><li>导航只能在下面？</li></ul><h2 id="数据获取" tabindex="-1"><a class="header-anchor" href="#数据获取" aria-hidden="true">#</a> 数据获取</h2><ul><li>必须用 request ?</li></ul><h2 id="引入-phpjs-报错" tabindex="-1"><a class="header-anchor" href="#引入-phpjs-报错" aria-hidden="true">#</a> 引入 phpjs 报错</h2><h2 id="navigateto-报-webview-id-已存在" tabindex="-1"><a class="header-anchor" href="#navigateto-报-webview-id-已存在" aria-hidden="true">#</a> navigateTo 报 webview id 已存在</h2><h2 id="过滤器-模板中不能执行传参函数" tabindex="-1"><a class="header-anchor" href="#过滤器-模板中不能执行传参函数" aria-hidden="true">#</a> 过滤器 / 模板中不能执行传参函数</h2><p>不能用 methods 和 computed</p><h2 id="navigateto-后的页面缓存" tabindex="-1"><a class="header-anchor" href="#navigateto-后的页面缓存" aria-hidden="true">#</a> navigateTo 后的页面缓存</h2><p>别的跳转方法不行 小程序逻辑层没有注销 组件，tabs 切换时会 onHide，页面跳转会 onUnload 逻辑层与视图层不一致，视图层有缓存，触发刷新有延迟</p><p>解决：卸载时，手动重置 data 中声明的值</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  onUnload () {\n    this.listItems = []\n    this.filterListItems = []\n    this.showLoading = true\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',14),h=t("这个是可能的，因为页面数据是存在于 js 中，切换页面的时候是会把数据 setData 到 render 进程中，可能有个老数据显示的闪现，目前的解决方式可以在 onHide 的时候重置数据或者加载 loading 动画，在 onShow 的时候加载数和或者取消 loading 动画。 后期考虑可以从底层优化掉闪现的问题。 "),u={href:"https://github.com/Meituan-Dianping/mpvue/issues/140#issuecomment-374563689",target:"_blank",rel:"noopener noreferrer"},o=t("同一路由切换时，上一次的页面数据会保留 · Issue #140 · Meituan-Dianping/mpvue"),p=s('<h2 id="路径获取" tabindex="-1"><a class="header-anchor" href="#路径获取" aria-hidden="true">#</a> 路径获取</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>this.$root.$mp.page.route\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="v-for-必须要有-index-最好把-key-也写上" tabindex="-1"><a class="header-anchor" href="#v-for-必须要有-index-最好把-key-也写上" aria-hidden="true">#</a> v-for 必须要有 index，最好把 key 也写上</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>v-for=&quot;(league, leagueIndex) in group&quot; :key=&quot;league.id&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="自定义组件" tabindex="-1"><a class="header-anchor" href="#自定义组件" aria-hidden="true">#</a> 自定义组件</h2>',5),c=t("mpvue 暂时不支持小程序的 Component "),b={href:"https://github.com/Meituan-Dianping/mpvue/issues/8#issuecomment-372009117",target:"_blank",rel:"noopener noreferrer"},g=t("mpvue是否能使用echarts？ · Issue #8 · Meituan-Dianping/mpvue"),m=i("h2",{id:"created-所有页面会同时触发",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#created-所有页面会同时触发","aria-hidden":"true"},"#"),t(" created 所有页面会同时触发")],-1),v=i("p",null,"小程序本身设计是会在刚打开的时候就初始化所有的 page，所以会直接触发 created 生命周期。 一般不要使用 created，这个地方跟 vue 不一样",-1);d.render=function(s,t){const d=e("OutboundLink");return a(),n(r,null,[l,i("blockquote",null,[i("p",null,[h,i("a",u,[o,i(d)])])]),p,i("p",null,[c,i("a",b,[g,i(d)])]),m,v],64)};export default d;
